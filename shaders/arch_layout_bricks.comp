#version 430
layout(local_size_x = 1, local_size_y = 1) in;
layout(rgba32f) uniform image2D road_mask;

// Same as the OpenGL defined struct: DrawElementsIndirectCommand
struct DrawCommand {
    uint count;         // Num elements (vertices)
    uint instanceCount; // Number of instances to draw (a.k.a primcount)
    uint firstIndex;    // Specifies a byte offset (cast to a pointer type) into the buffer bound to GL_ELEMENT_ARRAY_BUFFER to start reading indices from.
    uint baseVertex;    // Specifies a constant that should be added to each element of indicesâ€‹ when chosing elements from the enabled vertex arrays.
    uint baseInstance;  // Specifies the base instance for use in fetching instanced vertex attributes.
};

// Command buffer backed by a Shader Storage Object Buffer (SSBO)
layout(std140, binding = 0) writeonly buffer draw_commands {
    DrawCommand cmds[];
};

layout (std430, binding=2) buffer transforms_buffer { 
    mat4 transforms[];
};

struct ArchSegmentData {
    vec2 start;
    vec2 end;
};

layout (std430, binding=4) buffer segments_buffer { 
    ArchSegmentData segs[];
};

//------------------------------------

float arch_function(float h) {
    return 1.0 - pow(1.0 - h, 4.0);
}

ivec2 ws_pos_to_pixel_coord(vec3 ws_pos, ivec2 img_dims) {
    // the img is from -10 to 10 in world space TODO: this should be a uniform coming from a struct on CPU side...
    vec2 texture_uv = (ws_pos / 20.0 + 0.5).xz;
    return ivec2(texture_uv.x * img_dims.x, texture_uv.y * img_dims.y);
}

float position_ws_to_roadmask_value(vec3 position, ivec2 dims) {
    ivec2 pixel_coord = ws_pos_to_pixel_coord(position, dims);
    return imageLoad(road_mask, pixel_coord).x;
}

vec3 curve_ws_to_arch_ws(vec3 curve_ws) {
    curve_ws.y = position_ws_to_roadmask_value(curve_ws, imageSize(road_mask));
    curve_ws.y = arch_function(curve_ws.y);//pow(curve_ws.y, 0.3);
    return curve_ws;
}

float length_arch(vec3 from, vec3 to) {
    // subdivide the segment
    const uint SUBDIV = 30;
    float out_length = 0.0;

    for (int i=0; i<SUBDIV; i++) {

        vec3 subdiv_p1 = mix(from, to,  float(i) / float(SUBDIV));
        vec3 subdiv_p2 = mix(from, to, float(i+1) / float(SUBDIV));

        subdiv_p1 = curve_ws_to_arch_ws(subdiv_p1);
        subdiv_p2 = curve_ws_to_arch_ws(subdiv_p2);

        out_length += distance(subdiv_p1, subdiv_p2);
    }

    return out_length;
}


struct MarchData {
    vec3 arch_pos;
    int subdiv_id;
    float dist_traveled;
};


MarchData march_along_arch(float target_u, MarchData march_data_cache, vec3 seg_start, vec3 seg_end, float seg_length) {

    const int SUBDIV = 100;
    MarchData out_march_data;
    // check for quick 1s and 0s
    if (target_u < 0.01) {
        out_march_data.arch_pos = curve_ws_to_arch_ws(seg_start);
        out_march_data.subdiv_id = 0;
        out_march_data.dist_traveled = 0.0;
        return out_march_data;
    }
    
    if (target_u > 0.99) {
        out_march_data.arch_pos = curve_ws_to_arch_ws(seg_end);
        out_march_data.subdiv_id = SUBDIV;
        out_march_data.dist_traveled = seg_length;
        return out_march_data;
    }

    //////////
    float dist_traveled = march_data_cache.dist_traveled;
    vec3 current_arch_pos = march_data_cache.arch_pos;

    for (int i=march_data_cache.subdiv_id; i<SUBDIV+1; i++) {

        vec3 subdiv_p1 = current_arch_pos; 
        vec3 subdiv_p2 = mix(seg_start, seg_end,  float(i+1) / float(SUBDIV));
        subdiv_p2 = curve_ws_to_arch_ws(subdiv_p2);

        float current_u = dist_traveled / seg_length;

        if (current_u >= target_u) {
            //return vec4(current_arch_pos, float(i));
            out_march_data.arch_pos = subdiv_p2;
            out_march_data.subdiv_id = i+1;
            out_march_data.dist_traveled = dist_traveled;
            return out_march_data;
        }

        // make a step forward
        dist_traveled += distance(subdiv_p1, subdiv_p2);
        current_arch_pos = subdiv_p2;
    }

    out_march_data.arch_pos = vec3(3.0);
    out_march_data.subdiv_id = 0;
    out_march_data.dist_traveled = 0.0;

    return out_march_data; //vec4(0.0, 0.0, 0.0, 0.0);
}

//------------------------------------


void main() {
    
    float TARGET_BRICK_WIDTH = 0.2;
    uint idx = gl_GlobalInvocationID.x;

    vec3 seg_start = vec3(segs[idx].start.x, 0.0, segs[idx].start.y);
    vec3 seg_end = vec3(segs[idx].end.x, 0.0, segs[idx].end.y);


    // --------------------

    // TODO: redo, and do it per segment, and bricks pivot is just average like indirect_draw_test

    float seg_arch_length = length_arch(seg_start, seg_end);
    int total_segment_bricks = max(int(floor(seg_arch_length / TARGET_BRICK_WIDTH)), 1);
    //float brick_w = seg_arch_length / float(target_brick_count); 

    //MarchData march_along_arch(float target_u, MarchData march_data_cache, vec3 seg_start, vec3 seg_end, float seg_length) {
    MarchData dummy;
    MarchData march_data_cache = march_along_arch(0.0, dummy, seg_start, seg_end, seg_arch_length);

    for (int k=0; k<total_segment_bricks; k++) {
        float u1 = float(k) / float(total_segment_bricks);
        float u2 = float(k+1) / float(total_segment_bricks);

        MarchData new_march_step = march_along_arch(u2, march_data_cache, seg_start, seg_end, seg_arch_length);

        vec3 subseg_p1 = march_data_cache.arch_pos; 
        vec3 subseg_p2 = new_march_step.arch_pos;

        march_data_cache = new_march_step;

        vec3 pivot = (subseg_p1+subseg_p2) / 2.0;

        float width = distance(subseg_p1, subseg_p2);

        vec3 s = vec3(width, 0.15, 0.25);

        vec3 x = normalize(subseg_p2-subseg_p1);
        vec3 z = normalize(cross(x, vec3(0.0, 1.0, 0.0)));
        vec3 y = normalize(cross(x, z));

        mat4 scale = transpose(mat4(
            s.x, 0.0, 0.0, 0.0, 
            0.0, s.y, 0.0, 0.0, 
            0.0, 0.0, s.z, 0.0, 
            0.0, 0.0, 0.0, 1.0
        ));

        mat4 translate = transpose(mat4(
            1.0, 0.0, 0.0, pivot.x, 
            0.0, 1.0, 0.0, pivot.y, 
            0.0, 0.0, 1.0, pivot.z, 
            0.0, 0.0, 0.0, 1.0
        ));

        mat4 rotate = mat4(
            x.x, x.y, x.z, 0.0, 
            y.x, y.y, y.z, 0.0, 
            z.x, z.y, z.z, 0.0, 
            0.0, 0.0, 0.0, 1.0
        );

        uint instance_offset = atomicAdd(cmds[0].instanceCount, 1);
        transforms[instance_offset] = translate * rotate * scale;
        instance_offset += 1;
    }

    /*
    int current_march_id = 0;
    vec3 prev_arch_pos = curve_ws_to_arch_ws(start_pos);

    MarchData m = march_along_arch(brick_w / 2.0, current_march_id, start_pos, end_pos);
    vec3 tangent = normalize(m.arch_pos - prev_arch_pos);
    place_brick(m, brick_w, tangent);
    current_march_id = m.subdiv_id;
    prev_arch_pos = m.arch_pos;

    for (int i=1; i<target_brick_count; i++) {

        m = march_along_arch(brick_w, current_march_id, start_pos, end_pos);
        tangent = normalize(m.arch_pos - prev_arch_pos);
        place_brick(m, brick_w, tangent);
        current_march_id = m.subdiv_id;
        prev_arch_pos = m.arch_pos;

    }
    */
    
    // ------------------------

    /*

    // TEST just put bricks on top of segments
    uint instance_offset = atomicAdd(cmds[0].instanceCount, 2);

    mat4 translate = transpose(mat4(
        0.1, 0.0, 0.0, start_pos.x, 
        0.0, 0.1, 0.0, 0.0, //float(idx) / 10.0, 
        0.0, 0.0, 0.1, start_pos.z, 
        0.0, 0.0, 0.0, 1.0
    ));

    transforms[instance_offset] = translate;
    instance_offset += 1;

    translate = transpose(mat4(
        0.1, 0.0, 0.0, end_pos.x, 
        0.0, 0.1, 0.0, 0.0, //float(idx)/ 10.0, 
        0.0, 0.0, 0.1, end_pos.z, 
        0.0, 0.0, 0.0, 1.0
    ));

    transforms[instance_offset] = translate;
    */
}